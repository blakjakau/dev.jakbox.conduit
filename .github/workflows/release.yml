# .github/workflows/release.yml
name: Build, Sign, and Release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  build:
    name: Build & Sign (${{ matrix.os }}/${{ matrix.arch }})
    strategy:
      matrix:
        include:
          - os: macos-latest
            arch: amd64
            asset-name: conduit-macos-x64
          - os: macos-latest
            arch: arm64
            asset-name: conduit-macos-arm64
          - os: windows-latest
            arch: amd64
            asset-name: conduit-windows-x64.exe
    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      # --- macOS Build and Sign ---
      - name: Build macOS Binary
        if: runner.os == 'macOS'
        run: |
          export CGO_ENABLED=1
          export SDKROOT=$(xcrun --sdk macosx --show-sdk-path)
          GOOS=darwin GOARCH=${{ matrix.arch }} go build -ldflags="-s -w" -o ${{ matrix.asset-name }} .

      - name: Ad-hoc Sign macOS Binary
        if: runner.os == 'macOS'
        run: |
          cat <<EOF > entitlements.plist
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>com.apple.security.get-task-allow</key>
            <false/>
          </dict>
          </plist>
          EOF
          codesign --force --sign - --entitlements entitlements.plist ${{ matrix.asset-name }}

      # --- Windows Build and Sign ---
      - name: Build Windows Binary
        if: runner.os == 'Windows'
        run: go build -ldflags="-s -w" -o ${{ matrix.asset-name }} .

      - name: Sign Windows Binary
        if: runner.os == 'Windows'
        env:
          WINDOWS_CERT_PFX_BASE64: ${{ secrets.WINDOWS_CERT_PFX_BASE64 }}
          WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
        run: |
          # Decode PFX file from secret
          $pfx_cert_b64 = "${{ env.WINDOWS_CERT_PFX_BASE64 }}"
          $pfx_path = Join-Path -Path $env:RUNNER_TEMP -ChildPath "cert.pfx"
          [System.IO.File]::WriteAllBytes($pfx_path, [System.Convert]::FromBase64String($pfx_cert_b64))
          # Find the latest signtool.exe from the Windows SDK and store its path
          $signtoolPath = (Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\signtool.exe" | Sort-Object -Property VersionInfo -Descending | Select-Object -First 1).FullName
          if (-not $signtoolPath) { Write-Error "signtool.exe not found in Windows Kits 10 bin."; exit 1 }
          # Sign the file with a timestamp server
          & $signtoolPath sign /f $pfx_path /p "${{ env.WINDOWS_CERT_PASSWORD }}" /tr http://timestamp.digicert.com /td sha256 /fd sha256 "${{ matrix.asset-name }}"
        shell: pwsh

      # --- Upload Artifact ---
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.asset-name }}
          path: ${{ matrix.asset-name }}

  release:
    name: Create GitHub Release
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: dist

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*/*
          fail_on_unmatched_files: true